---
link: https://juejin.cn/post/6844903968338870285
title: 写给新手前端的各种文件上传攻略，从小图片到大文件断点续传
description: 今年国庆假期终于可以憋在家里了不用出门了，不用出去看后脑了，真的是一种享受。这么好的光阴怎么浪费，睡觉、吃饭、打豆豆这怎么可能（耍多了也烦），完全不符合我们程序员的作风，赶紧起来把文章写完。 这篇文章比较基础，在国庆期间的业余时间写的，这几天又完善了下，力求把更多的前端所涉及到…
keywords: JavaScript
author: 首页 首页 沸点 课程 直播 活动 竞赛 商城 App 插件 搜索历史 清空 创作者中心 写文章 发沸点 写笔记 写代码 草稿箱 创作灵感 查看更多 会员 登录 注册
date: 2019-10-17T02:15:20.000Z
publisher: 稀土掘金
stats: paragraph=231 sentences=368, words=2987
---
今年国庆假期终于可以憋在家里了不用出门了，不用出去看后脑了，真的是一种享受。这么好的光阴怎么浪费，睡觉、吃饭、打豆豆这怎么可能（耍多了也烦），完全不符合我们程序员的作风，赶紧起来把文章写完。

以下是本文所涉及到的知识点，break or continue ?

* 文件上传原理
* 最原始的文件上传
* 使用 koa2 作为服务端写一个文件上传接口
* 单文件上传和上传进度
* 多文件上传和上传进度
* 拖拽上传
* 剪贴板上传
* 大文件上传之分片上传
* 大文件上传之断点续传
* node 端文件上传

原理很简单，就是根据 http 协议的规范和定义，完成请求消息体的封装和消息体的解析，然后将二进制内容保存到文件。

我们都知道如果要上传一个文件，需要把 form 标签的 `enctype`设置为 `multipart/form-data`,同时 `method`必须为 `post`方法。

那么 `multipart/form-data`表示什么呢？

> multipart互联网上的混合资源，就是资源由多种元素组成，form-data表示可以使用HTML Forms 和 POST 方法上传文件，具体的定义可以参考RFC 7578。

`multipart/form-data` 结构

看下 http 请求的消息体

* 请求头：

`Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryDCntfiXcSkPhS4PN` 表示本次请求要上传文件，其中boundary表示分隔符，如果要上传多个表单项，就要使用boundary分割，每个表单项由———XXX开始，以———XXX结尾。

* 消息体- Form Data 部分

每一个表单项又由 `Content-Type`和 `Content-Disposition`组成。

`Content-Disposition: form-data` 为固定值，表示一个表单元素， `name` 表示表单元素的 名称，回车换行后面就是 `name`的值，如果是上传文件就是文件的二进制内容。

`Content-Type`：表示当前的内容的 MIME 类型，是图片还是文本还是二进制数据。

客户端发送请求到服务器后，服务器会收到请求的消息体，然后对消息体进行解析，解析出哪是普通表单哪些是附件。

可能大家马上能想到通过正则或者字符串处理分割出内容，不过这样是行不通的，二进制 `buffer`转化为 `string`,对字符串进行截取后，其索引和字符串是不一致的，所以结果就不会正确，除非上传的就是字符串。

不过一般情况下不需要自行解析，目前已经有很成熟的三方库可以使用。

至于如何解析，这个也会占用很大篇幅，后面的文章在详细说。

**使用 form 表单上传文件**

在 `ie`时代，如果实现一个无刷新的文件上传那可是费老劲了，大部分都是用 iframe 来实现局部刷新或者使用 flash 插件来搞定，在那个时代 ie 就是最好用的浏览器（别无选择）。

`DEMO`

这种方式上传文件，不需要 js ，而且没有兼容问题，所有浏览器都支持，就是体验很差，导致页面刷新，页面其他数据丢失。

`HTML`

```
 <form method="<span" class="hljs-string">"post" action=<span class="hljs-string">"http://localhost:8100"</span> enctype=<span class="hljs-string">"multipart/form-data"</span>>

        &#x9009;&#x62E9;&#x6587;&#x4EF6;:
            <input <span class="hljs-built_in">type=<span class="hljs-string">"file"</span> name=<span class="hljs-string">"f1"</span>/> input &#x5FC5;&#x987B;&#x8BBE;&#x7F6E; name &#x5C5E;&#x6027;&#xFF0C;&#x5426;&#x5219;&#x6570;&#x636E;&#x65E0;&#x6CD5;&#x53D1;&#x9001;

            &#x6807;&#x9898;&#xFF1A;<input <span class="hljs-built_in">type=<span class="hljs-string">"text"</span> name=<span class="hljs-string">"title"</span>/><br><br>

        <button <span class="hljs-built_in">type=<span class="hljs-string">"submit"</span> id=<span class="hljs-string">"btn-0"</span>>&#x4E0A; &#x4F20;</button>

</form>

```

服务端文件的保存基于现有的库 `koa-body`结合 `koa2`实现服务端文件的保存和数据的返回。

在项目开发中，文件上传本身和业务无关，代码基本上都可通用。

在这里我们使用 `koa-body`库来实现解析和文件的保存。

`koa-body` 会自动保存文件到系统临时目录下，也可以指定保存的文件路径。

然后在后续中间件内得到已保存的文件的信息，再做二次处理。

* `ctx.request.files.f1` 得到文件信息， `f1`为 `input file` 标签的 `name`
* 获得文件的扩展名，重命名文件

`NODE`

```
/**
 * &#x670D;&#x52A1;&#x5165;&#x53E3;
 */
var http = require(<span class="hljs-string">'http'</span>);
var koaStatic = require(<span class="hljs-string">'koa-static'</span>);
var path = require(<span class="hljs-string">'path'</span>);
var koaBody = require(<span class="hljs-string">'koa-body'</span>);//&#x6587;&#x4EF6;&#x4FDD;&#x5B58;&#x5E93;
var fs = require(<span class="hljs-string">'fs'</span>);
var Koa = require(<span class="hljs-string">'koa2'</span>);

var app = new Koa();
var port = process.env.PORT || <span class="hljs-string">'8100'</span>;

var uploadHost= `http://localhost:<span class="hljs-variable">${port}</span>/uploads/`;

app.use(koaBody({
    formidable: {
        //&#x8BBE;&#x7F6E;&#x6587;&#x4EF6;&#x7684;&#x9ED8;&#x8BA4;&#x4FDD;&#x5B58;&#x76EE;&#x5F55;&#xFF0C;&#x4E0D;&#x8BBE;&#x7F6E;&#x5219;&#x4FDD;&#x5B58;&#x5728;&#x7CFB;&#x7EDF;&#x4E34;&#x65F6;&#x76EE;&#x5F55;&#x4E0B;  os
        uploadDir: path.resolve(__dirname, <span class="hljs-string">'../static/uploads'</span>)
    },
    multipart: <span class="hljs-literal">true</span> // &#x5F00;&#x542F;&#x6587;&#x4EF6;&#x4E0A;&#x4F20;&#xFF0C;&#x9ED8;&#x8BA4;&#x662F;&#x5173;&#x95ED;
}));

//&#x5F00;&#x542F;&#x9759;&#x6001;&#x6587;&#x4EF6;&#x8BBF;&#x95EE;
app.use(koaStatic(
    path.resolve(__dirname, <span class="hljs-string">'../static'</span>)
));

//&#x6587;&#x4EF6;&#x4E8C;&#x6B21;&#x5904;&#x7406;&#xFF0C;&#x4FEE;&#x6539;&#x540D;&#x79F0;
app.use((ctx) => {
    var file = ctx.request.files.f1;//&#x5F97;&#x9053;&#x6587;&#x4EF6;&#x5BF9;&#x8C61;
    var path = file.path;
    var fname = file.name;//&#x539F;&#x6587;&#x4EF6;&#x540D;&#x79F0;
    var nextPath = path+fname;
    <span class="hljs-keyword">if</span>(file.size>0 && path){
        //&#x5F97;&#x5230;&#x6269;&#x5C55;&#x540D;
        var extArr = fname.split(<span class="hljs-string">'.'</span>);
        var ext = extArr[extArr.length-1];
        var nextPath = path+<span class="hljs-string">'.'</span>+ext;
        //&#x91CD;&#x547D;&#x540D;&#x6587;&#x4EF6;
        fs.renameSync(path, nextPath);
    }
    //&#x4EE5; json &#x5F62;&#x5F0F;&#x8F93;&#x51FA;&#x4E0A;&#x4F20;&#x6587;&#x4EF6;&#x5730;&#x5740;
    ctx.body = `{
        <span class="hljs-string">"fileUrl"</span>:<span class="hljs-string">"<span class="hljs-variable">${uploadHost}</span><span class="hljs-variable">${nextPath.slice(nextPath.lastIndexOf('/')+1)}</span>"</span>
    }`;
});

/**
 * http server
 */
var server = http.createServer(app.callback());
server.listen(port);
console.log(<span class="hljs-string">'demo1 server start ......   '</span>);
```

`CODE`

在 `ie` 时代的多文件上传是需要创建多个 `input file` 标签，现在 `html5`只需要一个标签加个属性就搞定了, `file` 标签开启 `multiple`。

`DEMO`

`HTML`

```
//&#x8BBE;&#x7F6E; multiple&#x5C5E;&#x6027;
<input <span class="hljs-built_in">type=<span class="hljs-string">"file"</span> name=<span class="hljs-string">"f1"</span> multiple/>
```

`NODE`

服务端也需要进行简单的调整，由单文件对象变为多文件数组，然后进行遍历处理。

```
//&#x4E8C;&#x6B21;&#x5904;&#x7406;&#x6587;&#x4EF6;&#xFF0C;&#x4FEE;&#x6539;&#x540D;&#x79F0;
app.use((ctx) => {

    var files = ctx.request.files.f1;// &#x591A;&#x6587;&#x4EF6;&#xFF0C; &#x5F97;&#x5230;&#x4E0A;&#x4F20;&#x6587;&#x4EF6;&#x7684;&#x6570;&#x7EC4;
    var result=[];

    //&#x904D;&#x5386;&#x5904;&#x7406;
    files && files.forEach(item=>{
        var path = item.path;
        var fname = item.name;//&#x539F;&#x6587;&#x4EF6;&#x540D;&#x79F0;
        var nextPath = path + fname;
        <span class="hljs-keyword">if</span> (item.size > 0 && path) {
            //&#x5F97;&#x5230;&#x6269;&#x5C55;&#x540D;
            var extArr = fname.split(<span class="hljs-string">'.'</span>);
            var ext = extArr[extArr.length - 1];
            var nextPath = path + <span class="hljs-string">'.'</span> + ext;
            //&#x91CD;&#x547D;&#x540D;&#x6587;&#x4EF6;
            fs.renameSync(path, nextPath);

            //&#x6587;&#x4EF6;&#x53EF;&#x8BBF;&#x95EE;&#x8DEF;&#x5F84;&#x653E;&#x5165;&#x6570;&#x7EC4;
            result.push(uploadHost+ nextPath.slice(nextPath.lastIndexOf(<span class="hljs-string">'/'</span>) + 1));
        }
    });

    //&#x8F93;&#x51FA; json &#x7ED3;&#x679C;
    ctx.body = `{
        <span class="hljs-string">"fileUrl"</span>:<span class="hljs-variable">${JSON.stringify(result)}</span>
    }`;
})
```

`CODE`

这里说的是在 `ie` 时代的上传文件局部刷新，借助 iframe 实现。

`DEMO`

* 局部刷新

页面内放一个隐藏的 `iframe`，或者使用 `js` 动态创建，指定 `form` 表单的 `target` 属性值为 `iframe`标签 的 `name` 属性值，这样 `form` 表单的 `shubmit` 行为的跳转就会在 `iframe` 内完成，整体页面不会刷新。

* 拿到接口数据

然后为 `iframe` 添加 `load`事件，得到 `iframe` 的页面内容，将结果转换为 `JSON` 对象，这样就拿到了接口的数据

`HTML`

```
   <iframe id="<span" class="hljs-string">"temp-iframe" name=<span class="hljs-string">"temp-iframe"</span> src=<span class="hljs-string">""</span> style=<span class="hljs-string">"display:none;"</span>></iframe>
        <form method="<span" class="hljs-string">"post" target=<span class="hljs-string">"temp-iframe"</span> action=<span class="hljs-string">"http://localhost:8100"</span> enctype=<span class="hljs-string">"multipart/form-data"</span>>
        &#x9009;&#x62E9;&#x6587;&#x4EF6;(&#x53EF;&#x591A;&#x9009;):
            <input <span class="hljs-built_in">type=<span class="hljs-string">"file"</span> name=<span class="hljs-string">"f1"</span> id=<span class="hljs-string">"f1"</span> multiple/><br> input &#x5FC5;&#x987B;&#x8BBE;&#x7F6E; name &#x5C5E;&#x6027;&#xFF0C;&#x5426;&#x5219;&#x6570;&#x636E;&#x65E0;&#x6CD5;&#x53D1;&#x9001;

            &#x6807;&#x9898;&#xFF1A;<input <span class="hljs-built_in">type=<span class="hljs-string">"text"</span> name=<span class="hljs-string">"title"</span>/><br><br>

        <button <span class="hljs-built_in">type=<span class="hljs-string">"submit"</span> id=<span class="hljs-string">"btn-0"</span>>&#x4E0A; &#x4F20;</button>

        </form>

<script>

var iframe = document.getElementById(<span class="hljs-string">'temp-iframe'</span>);
iframe.addEventListener(<span class="hljs-string">'load'</span>,<span class="hljs-function"><span class="hljs-title">function</span></span> () {
      var result = iframe.contentWindow.document.body.innerText;
      //接口数据转换为 JSON 对象
      var obj = JSON.parse(result);
      <span class="hljs-keyword">if</span>(obj && obj.fileUrl.length){
          alert(<span class="hljs-string">'上传成功'</span>);

      }
      console.log(obj);
});

</script>
```

`NODE`

服务端代码不需要改动，略.

`CODE`

无刷新上传文件肯定要用到 `XMLHttpRequest`,在 `ie` 时代也有这个对象，单只 支持文本数据的传输，无法用来读取和上传二进制数据。

现在已然升级到了 `XMLHttpRequest2`，较1版本有非常大的升级，首先就是可以读取和上传二进制数据，可以使用·FormData·对象管理表单数据。

当然也可使用 `fetch` 进行上传。

`DEMO`

`HTML`

```
 <div>
        &#x9009;&#x62E9;&#x6587;&#x4EF6;(&#x53EF;&#x591A;&#x9009;):
        <input <span class="hljs-built_in">type=<span class="hljs-string">"file"</span> id=<span class="hljs-string">"f1"</span> multiple/><br>
        <button <span class="hljs-built_in">type=<span class="hljs-string">"button"</span> id=<span class="hljs-string">"btn-submit"</span>>&#x4E0A; &#x4F20;</button>
</div>

```

`JS xhr`

```

<script>
    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">submitUpload</span></span>() {
        //获得文件列表，注意这里不是数组，而是对象
        var fileList = document.getElementById(<span class="hljs-string">'f1'</span>).files;
        <span class="hljs-keyword">if</span>(!fileList.length){
            alert(<span class="hljs-string">'请选择文件'</span>);
            <span class="hljs-built_in">return</span>;
        }
        var fd = new FormData();   //构造FormData对象
        fd.append(<span class="hljs-string">'title'</span>, document.getElementById(<span class="hljs-string">'title'</span>).value);

        //多文件上传需要遍历添加到 fromdata 对象
        <span class="hljs-keyword">for</span>(var i =0;i<fileList.length;i++){
            fd.append(<span class="hljs-string">'f1'</span>, fileList[i]);//支持多文件上传
        }

        var xhr = new XMLHttpRequest();   //创建对象
        xhr.open(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'http://localhost:8100/'</span>, <span class="hljs-literal">true</span>);

        xhr.send(fd);//发送时  Content-Type默认就是: multipart/form-data;
        xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-title">function</span></span> () {
            console.log(<span class="hljs-string">'state change'</span>, xhr.readyState);
            <span class="hljs-keyword">if</span> (this.readyState == 4 && this.status == 200) {
                var obj = JSON.parse(xhr.responseText);   //返回值
                console.log(obj);
                <span class="hljs-keyword">if</span>(obj.fileUrl.length){
                    alert(<span class="hljs-string">'上传成功'</span>);
                }
            }
        }

    }

    //绑定提交事件
    document.getElementById(<span class="hljs-string">'btn-submit'</span>).addEventListener(<span class="hljs-string">'click'</span>,submitUpload);
</script>

```

`JS Fetch`

```
  fetch(<span class="hljs-string">'http://localhost:8100/'</span>, {
            method: <span class="hljs-string">'POST'</span>,
            body: fd
        })
            .then(response => response.json())
            .then(response =>{
                console.log(response);
                <span class="hljs-keyword">if</span> (response.fileUrl.length) {
                    alert(<span class="hljs-string">'&#x4E0A;&#x4F20;&#x6210;&#x529F;'</span>);
                }
            } )
            .catch(error => console.error(<span class="hljs-string">'Error:'</span>, error));
```

`CODE`

借助 `XMLHttpRequest2`的能力，实现多个文件或者一个文件的上传进度条的显示。

`DEMO`

* 页面内增加一个用于显示进度的标签 `div.progress`
* `js` 内处理增加进度处理的监听函数 `xhr.upload.onprogress`
* `event.lengthComputable`这是一个状态，表示发送的长度有了变化，可计算
* `event.loaded`表示发送了多少字节
* `event.total`表示文件总大小
* 根据 `event.loaded`和 `event.total`计算进度，渲染 `div.progress`

## PS 特别提醒

`xhr.upload.onprogress`要写在 `xhr.send`方法前面，否则 `event.lengthComputable`状态不会改变，只有在最后一次才能获得，也就是 `100%`的时候.

`HTML`

```
 <div>

        &#x9009;&#x62E9;&#x6587;&#x4EF6;(&#x53EF;&#x591A;&#x9009;):
            <input <span class="hljs-built_in">type=<span class="hljs-string">"file"</span> id=<span class="hljs-string">"f1"</span> multiple/><br>

            <div id="<span" class="hljs-string">"progress">
                <span class="<span">"red"</span>>
            </div>

        <button <span class="hljs-built_in">type=<span class="hljs-string">"button"</span> id=<span class="hljs-string">"btn-submit"</span>>&#x4E0A; &#x4F20;</button>

    </div>
```

```
<script>

    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">submitUpload</span></span>() {
        var progressSpan = document.getElementById(<span class="hljs-string">'progress'</span>).firstElementChild;
        var fileList = document.getElementById(<span class="hljs-string">'f1'</span>).files;
        progressSpan.style.width=<span class="hljs-string">'0'</span>;
        progressSpan.classList.remove(<span class="hljs-string">'green'</span>);

        <span class="hljs-keyword">if</span>(!fileList.length){
            alert(<span class="hljs-string">'请选择文件'</span>);
            <span class="hljs-built_in">return</span>;
        }

        var fd = new FormData();   //构造FormData对象
        fd.append(<span class="hljs-string">'title'</span>, document.getElementById(<span class="hljs-string">'title'</span>).value);

        <span class="hljs-keyword">for</span>(var i =0;i<fileList.length;i++){
            fd.append(<span class="hljs-string">'f1'</span>, fileList[i]);//支持多文件上传
        }

        var xhr = new XMLHttpRequest();   //创建对象
        xhr.open(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'http://10.70.65.235:8100/'</span>, <span class="hljs-literal">true</span>);

        xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-title">function</span></span> () {
            console.log(<span class="hljs-string">'state change'</span>, xhr.readyState);
            <span class="hljs-keyword">if</span> (xhr.readyState == 4) {
                var obj = JSON.parse(xhr.responseText);   //返回值
                console.log(obj);
                <span class="hljs-keyword">if</span>(obj.fileUrl.length){
                    //alert(<span class="hljs-string">'上传成功'</span>);
                }
            }
        }

        xhr.onprogress=updateProgress;
        xhr.upload.onprogress = updateProgress;
        <span class="hljs-keyword">function</span> updateProgress(event) {
            console.log(event);
            <span class="hljs-keyword">if</span> (event.lengthComputable) {
                var completedPercent = (event.loaded / event.total * 100).toFixed(2);
                progressSpan.style.width= completedPercent+<span class="hljs-string">'%'</span>;
                progressSpan.innerHTML=completedPercent+<span class="hljs-string">'%'</span>;
                <span class="hljs-keyword">if</span>(completedPercent>90){//进度条变色
                    progressSpan.classList.add(<span class="hljs-string">'green'</span>);
                }
                console.log(<span class="hljs-string">'已上传'</span>,completedPercent);
            }
        }
        //注意 send 一定要写在最下面，否则 onprogress 只会执行最后一次 也就是100%的时候
        xhr.send(fd);//发送时  Content-Type默认就是: multipart/form-data;
    }
    //绑定提交事件
    document.getElementById(<span class="hljs-string">'btn-submit'</span>).addEventListener(<span class="hljs-string">'click'</span>,submitUpload);

</script>
```

`CODE`

上一个栗子的多文件上传只有一个进度条，有些需求可能会不大一样，需要观察到每个文件的上传进度，并且可以终止上传。

`DEMO`

* 为了预览的需要，我们这里选择上传图片文件，其他类型的也一样，只是预览不方便
* 页面内增加一个多图预览的容器 `div.img-box`
* 根据选择的文件信息动态创建所属的预览区域和进度条以及取消按钮
* 为取消按钮绑定事件，调用 `xhr.abort();`终止上传
* 使用 `window.URL.createObjectURL`预览图片，在图片加载成功后需要清除使用的内存 `window.URL.revokeObjectURL(this.src);`

`HTML`

```
 <div>
        &#x9009;&#x62E9;&#x6587;&#x4EF6;(&#x53EF;&#x591A;&#x9009;):
        <div class="<span">"addfile">&#x6DFB;&#x52A0;&#x6587;&#x4EF6;
            <input <span class="hljs-built_in">type=<span class="hljs-string">"file"</span> id=<span class="hljs-string">"f1"</span> multiple />
        </div>
        <div class="<span">"img-box"></div>
        <button <span class="hljs-built_in">type=<span class="hljs-string">"button"</span> id=<span class="hljs-string">"btn-submit"</span>>&#x4E0A; &#x4F20;</button>
    </div>
```

```
<script>
    //更改网络 为慢3g，就可以比较明显的看到进度条了
    var fileMaxCount=6;
    var imgBox =document.getElementsByClassName(<span class="hljs-string">'img-box'</span>)[0];
    var willUploadFile=[];//保存待上传的文件以及相关附属信息
    document.getElementById(<span class="hljs-string">'f1'</span>).addEventListener(<span class="hljs-string">'change'</span>,<span class="hljs-keyword">function</span> (e) {
        var fileList = document.getElementById(<span class="hljs-string">'f1'</span>).files;

        <span class="hljs-keyword">if</span> (willUploadFile.length > fileMaxCount || fileList.length>fileMaxCount || (willUploadFile.length+ fileList.length>fileMaxCount)) {
            alert(<span class="hljs-string">'最多只能上传'</span> + fileMaxCount + <span class="hljs-string">'张图'</span>);
            <span class="hljs-built_in">return</span>;
        }
        <span class="hljs-keyword">for</span> (var i = 0; i < fileList.length; i++) {
            var f = fileList[i];//先预览图片
            var img = document.createElement(<span class="hljs-string">'img'</span>);
            var item = document.createElement(<span class="hljs-string">'div'</span>);
            var progress = document.createElement(<span class="hljs-string">'div'</span>);
            progress.className=<span class="hljs-string">'progress'</span>;
            progress.innerHTML = <span class="hljs-string">'<span class="red"></span><button type="button">Abort</button>'</span>;
            item.className=<span class="hljs-string">'item'</span>;
            img.src = window.URL.createObjectURL(f);
            img.onload = <span class="hljs-function"><span class="hljs-title">function</span></span> () {
                //显示要是否这块儿内存
                window.URL.revokeObjectURL(this.src);
            }

            item.appendChild(img);
            item.appendChild(progress);
            imgBox.appendChild(item);

            willUploadFile.push({
                file:f,
                item,
                progress
            });
        }
    });

    <span class="hljs-keyword">function</span> xhrSend({file, progress}) {

        var progressSpan = progress.firstElementChild;
        var btnCancel = progress.getElementsByTagName(<span class="hljs-string">'button'</span>)[0];
        var abortFn=<span class="hljs-function"><span class="hljs-title">function</span></span>(){
              <span class="hljs-keyword">if</span>(xhr && xhr.readyState!==4){
               //取消上传
               xhr.abort();
           }
        }
        btnCancel.removeEventListener(<span class="hljs-string">'click'</span>,abortFn);
        btnCancel.addEventListener(<span class="hljs-string">'click'</span>,abortFn);

        progressSpan.style.width=<span class="hljs-string">'0'</span>;
        progressSpan.classList.remove(<span class="hljs-string">'green'</span>);

        var fd = new FormData();   //构造FormData对象
        fd.append(<span class="hljs-string">'f1'</span>,file);

        var xhr = new XMLHttpRequest();   //创建对象
        xhr.open(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'http://localhost:8100/'</span>, <span class="hljs-literal">true</span>);

        xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-title">function</span></span> () {
            console.log(<span class="hljs-string">'state change'</span>, xhr.readyState);
            //调用 abort 后，state 立即变成了4,并不会变成0
            //增加自定义属性  xhr.uploaded
            <span class="hljs-keyword">if</span> (xhr.readyState == 4 &&  xhr.uploaded) {
                var obj = JSON.parse(xhr.responseText);   //返回值
                console.log(obj);
                <span class="hljs-keyword">if</span>(obj.fileUrl.length){
                    //alert(<span class="hljs-string">'上传成功'</span>);
                }
            }
        }

        xhr.onprogress=updateProgress;
        xhr.upload.onprogress = updateProgress;
        <span class="hljs-keyword">function</span> updateProgress(event) {
            <span class="hljs-keyword">if</span> (event.lengthComputable) {
                var completedPercent = (event.loaded / event.total * 100).toFixed(2);
                progressSpan.style.width= completedPercent+<span class="hljs-string">'%'</span>;
                progressSpan.innerHTML=completedPercent+<span class="hljs-string">'%'</span>;
                <span class="hljs-keyword">if</span>(completedPercent>90){//进度条变色
                    progressSpan.classList.add(<span class="hljs-string">'green'</span>);
                }
                <span class="hljs-keyword">if</span>(completedPercent>=100){
                    xhr.uploaded=<span class="hljs-literal">true</span>;
                }
                console.log(<span class="hljs-string">'已上传'</span>,completedPercent);
            }
        }
        //注意 send 一定要写在最下面，否则 onprogress 只会执行最后一次 也就是100%的时候
        xhr.send(fd);//发送时  Content-Type默认就是: multipart/form-data;
        <span class="hljs-built_in">return</span> xhr;
    }

    //文件上传
    <span class="hljs-keyword">function</span> submitUpload(willFiles) {
        <span class="hljs-keyword">if</span>(!willFiles.length){
            <span class="hljs-built_in">return</span>;
        }
        //遍历文件信息进行上传
        willFiles.forEach(<span class="hljs-keyword">function</span> (item) {
             xhrSend({
                 file:item.file,
                 progress:item.progress
             });
        });
    }
    //绑定提交事件
    document.getElementById(<span class="hljs-string">'btn-submit'</span>).addEventListener(<span class="hljs-string">'click'</span>,<span class="hljs-function"><span class="hljs-title">function</span></span> () {
        submitUpload(willUploadFile);
    });

</script>
```

## 问题1

这里没有做上传的并发控制，可以通过控制同时可上传文件的个数（这里控制为最多6个）或者上传的时候做好并发处理，也就是同时只能上传 X 个文件。

## 问题2

在测试过程中，取消请求的方法 `xhr.abort()`调用后， `xhr.readyState`会立即变为 `4`,而不是 `0`，所以这里需要做容错处理。

MDN 上说是0.

如果大家有不同的结果，欢迎留言。

`CODE`

`html5`的出现，让拖拽上传交互成为可能，现在这样的体验也屡见不鲜。

`DEMO`

* 定义一个允许拖放文件的区域 `div.drop-box`
* 取消 `drop` 事件的默认行为 `e.preventDefault();`，不然浏览器会直接打开文件
* 为拖拽区域绑定事件,鼠标在拖拽区域上 `dragover`, 鼠标离开拖拽区域 `dragleave`, 在拖拽区域上释放文件 `drop`
* `drop`事件内获得文件信息 `e.dataTransfer.files`

`HTML`

```
 <div class="<span">"drop-box" id=<span class="hljs-string">"drop-box"</span>>
       &#x62D6;&#x52A8;&#x6587;&#x4EF6;&#x5230;&#x8FD9;&#x91CC;,&#x5F00;&#x59CB;&#x4E0A;&#x4F20;
    </div>

    <button <span class="hljs-built_in">type=<span class="hljs-string">"button"</span> id=<span class="hljs-string">"btn-submit"</span>>&#x4E0A; &#x4F20;</button>
```

```
<script>

    var box = document.getElementById(<span class="hljs-string">'drop-box'</span>);

    //禁用浏览器的拖放默认行为
    document.addEventListener(<span class="hljs-string">'drop'</span>,<span class="hljs-keyword">function</span> (e) {
        console.log(<span class="hljs-string">'document drog'</span>);
        e.preventDefault();
    });

    //设置拖拽事件
    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">openDropEvent</span></span>() {
        box.addEventListener(<span class="hljs-string">"dragover"</span>,<span class="hljs-keyword">function</span> (e) {
            console.log(<span class="hljs-string">'elemenet dragover'</span>);
             box.classList.add(<span class="hljs-string">'over'</span>);
               e.preventDefault();
        });
         box.addEventListener(<span class="hljs-string">"dragleave"</span>, <span class="hljs-keyword">function</span> (e) {
              console.log(<span class="hljs-string">'elemenet dragleave'</span>);
            box.classList.remove(<span class="hljs-string">'over'</span>);
              e.preventDefault();
        });

        box.addEventListener(<span class="hljs-string">"drop"</span>, <span class="hljs-keyword">function</span> (e) {
            e.preventDefault(); //取消浏览器默认拖拽效果

            var fileList = e.dataTransfer.files; //获取拖拽中的文件对象
            var len=fileList.length;//用来获取文件的长度（其实是获得文件数量）

            //检测是否是拖拽文件到页面的操作
            <span class="hljs-keyword">if</span> (!len) {
                box.classList.remove(<span class="hljs-string">'over'</span>);
                <span class="hljs-built_in">return</span>;
            }

            box.classList.add(<span class="hljs-string">'over'</span>);

            window.willUploadFileList=fileList;

        }, <span class="hljs-literal">false</span>);
    }

    openDropEvent();

    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">submitUpload</span></span>() {

        var fileList = window.willUploadFileList||[];
        <span class="hljs-keyword">if</span>(!fileList.length){
            alert(<span class="hljs-string">'请选择文件'</span>);
            <span class="hljs-built_in">return</span>;
        }

        var fd = new FormData();   //构造FormData对象

        <span class="hljs-keyword">for</span>(var i =0;i<fileList.length;i++){
            fd.append(<span class="hljs-string">'f1'</span>, fileList[i]);//支持多文件上传
        }

        var xhr = new XMLHttpRequest();   //创建对象
        xhr.open(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'http://localhost:8100/'</span>, <span class="hljs-literal">true</span>);
        xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-title">function</span></span> () {
            <span class="hljs-keyword">if</span> (xhr.readyState == 4) {
                var obj = JSON.parse(xhr.responseText);   //返回值
                <span class="hljs-keyword">if</span>(obj.fileUrl.length){
                    alert(<span class="hljs-string">'上传成功'</span>);
                }
            }
        }
        xhr.send(fd);//发送
    }
    //绑定提交事件
    document.getElementById(<span class="hljs-string">'btn-submit'</span>).addEventListener(<span class="hljs-string">'click'</span>,submitUpload);

</script>
```

`CODE`

掘金的写文编辑器是支持粘贴上传图片的，比如我从磁盘粘贴或者从网页上右键复制图片。

`DEMO`

* 页面内增加一个可编辑的编辑区域 `div.editor-box`,开启 `contenteditable`
* 为 `div.editor-box`绑定 `paste`事件
* 处理 `paste` 事件，从 `event.clipboardData || window.clipboardData`获得数据
* 将数据转换为文件 `items[i].getAsFile()`
* 实现在编辑区域的光标处插入内容 `insertNodeToEditor` 方法

## 问题1

测试中发现复制多个文件无效，只有最后一个文件上传，在掘金的编辑器里也同样存在，在坐有知道原因的可以留言说下。

## 问题2

`mac`系统可以支持从磁盘复制文件后上传， `windows` 系统测试未通过，剪贴板的数据未拿到。

`HTML`

```
 <div class="<span">"editor-box" id=<span class="hljs-string">"editor-box"</span> contenteditable=<span class="hljs-string">"true"</span> >
       &#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x7C98;&#x8D34;&#x56FE;&#x7247;&#x5230;&#x8FD9;&#x91CC;&#x76F4;&#x63A5;&#x4E0A;&#x4F20;
 </div>
```

```
 //&#x5149;&#x6807;&#x5904;&#x63D2;&#x5165; dom &#x8282;&#x70B9;
    <span class="hljs-keyword">function</span>  insertNodeToEditor(editor,ele) {
        //&#x63D2;&#x5165;dom &#x8282;&#x70B9;
        var range;//&#x8BB0;&#x5F55;&#x5149;&#x6807;&#x4F4D;&#x7F6E;&#x5BF9;&#x8C61;
        var node = window.getSelection().anchorNode;
        // &#x8FD9;&#x91CC;&#x5224;&#x65AD;&#x662F;&#x505A;&#x662F;&#x5426;&#x6709;&#x5149;&#x6807;&#x5224;&#x65AD;&#xFF0C;&#x56E0;&#x4E3A;&#x5F39;&#x51FA;&#x6846;&#x9ED8;&#x8BA4;&#x662F;&#x6CA1;&#x6709;&#x7684;
        <span class="hljs-keyword">if</span> (node != null) {
            range = window.getSelection().getRangeAt(0);// &#x83B7;&#x53D6;&#x5149;&#x6807;&#x8D77;&#x59CB;&#x4F4D;&#x7F6E;
            range.insertNode(ele);// &#x5728;&#x5149;&#x6807;&#x4F4D;&#x7F6E;&#x63D2;&#x5165;&#x8BE5;&#x5BF9;&#x8C61;
        } <span class="hljs-keyword">else</span> {
            editor.append(ele);
        }
    }

    var box = document.getElementById(<span class="hljs-string">'editor-box'</span>);
    //&#x7ED1;&#x5B9A;paste&#x4E8B;&#x4EF6;
    box.addEventListener(<span class="hljs-string">'paste'</span>,<span class="hljs-keyword">function</span> (event) {
        var data = (event.clipboardData || window.clipboardData);

        var items = data.items;
        var fileList = [];//&#x5B58;&#x50A8;&#x6587;&#x4EF6;&#x6570;&#x636E;
        <span class="hljs-keyword">if</span> (items && items.length) {
            // &#x68C0;&#x7D22;&#x526A;&#x5207;&#x677F;items
            <span class="hljs-keyword">for</span> (var i = 0; i < items.length; i++) {
                console.log(items[i].getAsFile());
                fileList.push(items[i].getAsFile());
            }
        }

        window.willUploadFileList = fileList;
        event.preventDefault();//&#x963B;&#x6B62;&#x9ED8;&#x8BA4;&#x884C;&#x4E3A;

        submitUpload();
    });

    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">submitUpload</span></span>() {

        var fileList = window.willUploadFileList||[];
        var fd = new FormData();   //&#x6784;&#x9020;FormData&#x5BF9;&#x8C61;
        <span class="hljs-keyword">for</span>(var i =0;i<filelist.length;i++){ fd.append(<span class="hljs-string">'f1', fileList[i]);//&#x652F;&#x6301;&#x591A;&#x6587;&#x4EF6;&#x4E0A;&#x4F20;
        }
        var xhr = new XMLHttpRequest();   //&#x521B;&#x5EFA;&#x5BF9;&#x8C61;
        xhr.open(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'http://localhost:8100/'</span>, <span class="hljs-literal">true</span>);
        xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-title">function</span></span> () {
            <span class="hljs-keyword">if</span> (xhr.readyState === 4) {
                var obj = JSON.parse(xhr.responseText);   //&#x8FD4;&#x56DE;&#x503C;
                console.log(obj);
                <span class="hljs-keyword">if</span>(obj.fileUrl.length){
                    var img = document.createElement(<span class="hljs-string">'img'</span>);
                    img.src= obj.fileUrl[0];
                    img.style.width=<span class="hljs-string">'100px'</span>;
                    insertNodeToEditor(box,img);
                   // alert(<span class="hljs-string">'&#x4E0A;&#x4F20;&#x6210;&#x529F;'</span>);
                }
            }
        }

        xhr.send(fd);//&#x53D1;&#x9001;
    }

</filelist.length;i++){>
```

`CODE`

在 `ie` 时代由于无法使用 `xhr`上传二进制数据，上传大文件需要借助浏览器插件来完成。 现在来看实现大文件上传简直soeasy。

如果太大的文件，比如一个视频1g 2g那么大，直接采用上面的栗子中的方法上传可能会出链接现超时的情况，而且也会超过服务端允许上传文件的大小限制，所以解决这个问题我们可以将文件进行分片上传，每次只上传很小的一部分 比如2M。

`DEMO`

相信大家都对 `Blob` 对象有所了解，它表示原始数据,也就是二进制数据，同时提供了对数据截取的方法 `slice`,而 `File` 继承了 `Blob`的功能，所以可以直接使用此方法对数据进行分段截图。

* 把大文件进行分段 比如2M，发送到服务器携带一个标志，暂时用当前的时间戳，用于标识一个完整的文件
* 服务端保存各段文件
* 浏览器端所有分片上传完成，发送给服务端一个合并文件的请求
* 服务端根据文件标识、类型、各分片顺序进行文件合并
* 删除分片文件

`HTML`

代码略，只需要一个 `input file` 标签。

```
   //&#x5206;&#x7247;&#x903B;&#x8F91;  &#x50CF;&#x64CD;&#x4F5C;&#x5B57;&#x7B26;&#x4E32;&#x4E00;&#x6837;

    var start=0,end=0;
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        end+=chunkSize;
        var blob = file.slice(start,end);
        start+=chunkSize;

        <span class="hljs-keyword">if</span>(!blob.size){//&#x622A;&#x53D6;&#x7684;&#x6570;&#x636E;&#x4E3A;&#x7A7A; &#x5219;&#x7ED3;&#x675F;
            //&#x62C6;&#x5206;&#x7ED3;&#x675F;
            <span class="hljs-built_in">break</span>;
        }

        chunks.push(blob);//&#x4FDD;&#x5B58;&#x5206;&#x6BB5;&#x6570;&#x636E;
    }

<script>
    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">submitUpload</span></span>() {
        var chunkSize=2*1024*1024;//分片大小 2M
        var file = document.getElementById(<span class="hljs-string">'f1'</span>).files[0];
        var chunks=[], //保存分片数据
         token = (+ new Date()),//时间戳
         name =file.name,chunkCount=0,sendChunkCount=0;

        //拆分文件 像操作字符串一样
        <span class="hljs-keyword">if</span>(file.size>chunkSize){
            //拆分文件
            var start=0,end=0;
            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                end+=chunkSize;
                var blob = file.slice(start,end);
                start+=chunkSize;

                <span class="hljs-keyword">if</span>(!blob.size){//截取的数据为空 则结束
                    //拆分结束
                    <span class="hljs-built_in">break</span>;
                }

                chunks.push(blob);//保存分段数据
            }
        }<span class="hljs-keyword">else</span>{
            chunks.push(file.slice(0));
        }

        chunkCount=chunks.length;//分片的个数

        //没有做并发限制，较大文件导致并发过多，tcp 链接被占光 ，需要做下并发控制，比如只有4个在请求在发送

        <span class="hljs-keyword">for</span>(var i=0;i< chunkCount;i++){
            var fd = new FormData();   //构造FormData对象
            fd.append(<span class="hljs-string">'token'</span>, token);
            fd.append(<span class="hljs-string">'f1'</span>, chunks[i]);
            fd.append(<span class="hljs-string">'index'</span>, i);
            xhrSend(fd,<span class="hljs-function"><span class="hljs-title">function</span></span> () {
                sendChunkCount+=1;
                <span class="hljs-keyword">if</span>(sendChunkCount===chunkCount){//上传完成，发送合并请求
                    console.log(<span class="hljs-string">'上传完成，发送合并请求'</span>);
                    var formD = new FormData();
                    formD.append(<span class="hljs-string">'type'</span>,<span class="hljs-string">'merge'</span>);
                    formD.append(<span class="hljs-string">'token'</span>,token);
                    formD.append(<span class="hljs-string">'chunkCount'</span>,chunkCount);
                    formD.append(<span class="hljs-string">'filename'</span>,name);
                    xhrSend(formD);
                }
            });
        }
    }

    <span class="hljs-keyword">function</span> xhrSend(fd,cb) {

        var xhr = new XMLHttpRequest();   //创建对象
        xhr.open(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'http://localhost:8100/'</span>, <span class="hljs-literal">true</span>);
        xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-title">function</span></span> () {
            console.log(<span class="hljs-string">'state change'</span>, xhr.readyState);
            <span class="hljs-keyword">if</span> (xhr.readyState == 4) {
                console.log(xhr.responseText);
                cb && cb();
            }
        }
        xhr.send(fd);//发送
    }

    //绑定提交事件
    document.getElementById(<span class="hljs-string">'btn-submit'</span>).addEventListener(<span class="hljs-string">'click'</span>,submitUpload);
</script>

```

`NODE`

服务端需要做一些改动，保存分片文件、合并分段文件、删除分段文件。

合并文件这里使用 `stream pipe` 实现，这样更节省内存，边读边写入，占用内存更小，效率更高，代码见 `fnMergeFile`方法。

```
//&#x4E8C;&#x6B21;&#x5904;&#x7406;&#x6587;&#x4EF6;&#xFF0C;&#x4FEE;&#x6539;&#x540D;&#x79F0;
app.use((ctx) => {
    var body = ctx.request.body;
    var files = ctx.request.files ? ctx.request.files.f1:[];//&#x5F97;&#x5230;&#x4E0A;&#x4F20;&#x6587;&#x4EF6;&#x7684;&#x6570;&#x7EC4;
    var result=[];
    var fileToken = ctx.request.body.token;// &#x6587;&#x4EF6;&#x6807;&#x8BC6;
    var fileIndex=ctx.request.body.index;//&#x6587;&#x4EF6;&#x987A;&#x5E8F;

    <span class="hljs-keyword">if</span>(files &&  !Array.isArray(files)){//&#x5355;&#x6587;&#x4EF6;&#x4E0A;&#x4F20;&#x5BB9;&#x9519;
        files=[files];
    }

    files && files.forEach(item=>{
        var path = item.path;
        var fname = item.name;//&#x539F;&#x6587;&#x4EF6;&#x540D;&#x79F0;
        var nextPath = path.slice(0, path.lastIndexOf(<span class="hljs-string">'/'</span>) + 1) + fileIndex + <span class="hljs-string">'-'</span> + fileToken;
        <span class="hljs-keyword">if</span> (item.size > 0 && path) {
            //&#x5F97;&#x5230;&#x6269;&#x5C55;&#x540D;
            var extArr = fname.split(<span class="hljs-string">'.'</span>);
            var ext = extArr[extArr.length - 1];
            //var nextPath = path + <span class="hljs-string">'.'</span> + ext;
            //&#x91CD;&#x547D;&#x540D;&#x6587;&#x4EF6;
            fs.renameSync(path, nextPath);
            result.push(uploadHost+nextPath.slice(nextPath.lastIndexOf(<span class="hljs-string">'/'</span>) + 1));
        }
    });

    <span class="hljs-keyword">if</span>(body.type===<span class="hljs-string">'merge'</span>){//&#x5408;&#x5E76;&#x5206;&#x7247;&#x6587;&#x4EF6;
        var filename = body.filename,
        chunkCount = body.chunkCount,
            folder = path.resolve(__dirname, <span class="hljs-string">'../static/uploads'</span>)+<span class="hljs-string">'/'</span>;

        var writeStream = fs.createWriteStream(`<span class="hljs-variable">${folder}</span><span class="hljs-variable">${filename}</span>`);

        var cindex=0;
        //&#x5408;&#x5E76;&#x6587;&#x4EF6;
        <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fnMergeFile</span></span>(){
            var fname = `<span class="hljs-variable">${folder}</span><span class="hljs-variable">${cindex}</span>-<span class="hljs-variable">${fileToken}</span>`;
            var <span class="hljs-built_in">read</span>Stream = fs.createReadStream(fname);
            <span class="hljs-built_in">read</span>Stream.pipe(writeStream, { end: <span class="hljs-literal">false</span> });
            <span class="hljs-built_in">read</span>Stream.on(<span class="hljs-string">"end"</span>, <span class="hljs-function"><span class="hljs-title">function</span></span> () {
                fs.unlink(fname, <span class="hljs-keyword">function</span> (err) {
                    <span class="hljs-keyword">if</span> (err) {
                        throw err;
                    }
                });
                <span class="hljs-keyword">if</span> (cindex+1 < chunkCount){
                    cindex += 1;
                    fnMergeFile();
                }
            });
        }
        fnMergeFile();
        ctx.body=<span class="hljs-string">'merge ok 200'</span>;
    }

});
```

`CODE`

在上面我们实现了大文件的分片上传，解决了大文件上传超时和服务器的限制。

但是仍然不够完美，大文件上传并不是短时间内就上传完成，如果期间断网，页面刷新了仍然需要重头上传,这种时间的浪费怎么能忍？

所以我们实现断点续传，已上传的部分跳过，只传未上传的部分。

## 方法1

在上面我们实现了文件分片上传和最终的合并，现在要做的就是如何检测这些分片，不再重新上传即可。 这里我们可以在本地进行保存已上传成功的分片，重新上传的时候使用 `spark-md5`来生成文件 hash，区分此文件是否已上传。

* 为每个分段生成 hash 值，使用 `spark-md5` 库
* 将上传成功的分段信息保存到本地
* 重新上传时，进行和本地分段 hash 值的对比，如果相同的话则跳过，继续下一个分段的上传

生成 hash 过程肯定也会耗费资源，但是和重新上传相比可以忽略不计了。

`DEMO`

`HTML`

```
&#x4EE3;&#x7801;&#x7565;
```

模拟分段保存，本地保存到 `localStorage`

```

    //&#x83B7;&#x5F97;&#x672C;&#x5730;&#x7F13;&#x5B58;&#x7684;&#x6570;&#x636E;
    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">getUploadedFromStorage</span></span>(){
        <span class="hljs-built_in">return</span> JSON.parse( <span class="hljs-built_in">local</span>Storage.getItem(saveChunkKey) || <span class="hljs-string">"{}"</span>);
    }

    //&#x5199;&#x5165;&#x7F13;&#x5B58;
    <span class="hljs-keyword">function</span> <span class="hljs-built_in">set</span>UploadedToStorage(index) {
        var obj =  getUploadedFromStorage();
        obj[index]=<span class="hljs-literal">true</span>;
        <span class="hljs-built_in">local</span>Storage.setItem(saveChunkKey, JSON.stringify(obj) );
    }

    //&#x5206;&#x6BB5;&#x5BF9;&#x6BD4;

    var uploadedInfo = getUploadedFromStorage();//&#x83B7;&#x5F97;&#x5DF2;&#x4E0A;&#x4F20;&#x7684;&#x5206;&#x6BB5;&#x4FE1;&#x606F;

    <span class="hljs-keyword">for</span>(var i=0;i< chunkCount;i++){
            console.log(<span class="hljs-string">'index'</span>,i, uploadedInfo[i]?<span class="hljs-string">'&#x5DF2;&#x4E0A;&#x4F20;&#x8FC7;'</span>:<span class="hljs-string">'&#x672A;&#x4E0A;&#x4F20;'</span>);

            <span class="hljs-keyword">if</span>(uploadedInfo[i]){//&#x5BF9;&#x6BD4;&#x5206;&#x6BB5;
                sendChunkCount=i+1;//&#x8BB0;&#x5F55;&#x5DF2;&#x4E0A;&#x4F20;&#x7684;&#x7D22;&#x5F15;
                <span class="hljs-built_in">continue</span>;//&#x5982;&#x679C;&#x5DF2;&#x4E0A;&#x4F20;&#x5219;&#x8DF3;&#x8FC7;
            }
            var fd = new FormData();   //&#x6784;&#x9020;FormData&#x5BF9;&#x8C61;
            fd.append(<span class="hljs-string">'token'</span>, token);
            fd.append(<span class="hljs-string">'f1'</span>, chunks[i]);
            fd.append(<span class="hljs-string">'index'</span>, i);

           (<span class="hljs-keyword">function</span> (index) {
                    xhrSend(fd, <span class="hljs-function"><span class="hljs-title">function</span></span> () {
                    sendChunkCount += 1;
                    //&#x5C06;&#x6210;&#x529F;&#x4FE1;&#x606F;&#x4FDD;&#x5B58;&#x5230;&#x672C;&#x5730;
                    <span class="hljs-built_in">set</span>UploadedToStorage(index);
                    <span class="hljs-keyword">if</span> (sendChunkCount === chunkCount) {
                        console.log(<span class="hljs-string">'&#x4E0A;&#x4F20;&#x5B8C;&#x6210;&#xFF0C;&#x53D1;&#x9001;&#x5408;&#x5E76;&#x8BF7;&#x6C42;'</span>);
                        var formD = new FormData();
                        formD.append(<span class="hljs-string">'type'</span>, <span class="hljs-string">'merge'</span>);
                        formD.append(<span class="hljs-string">'token'</span>, token);
                        formD.append(<span class="hljs-string">'chunkCount'</span>, chunkCount);
                        formD.append(<span class="hljs-string">'filename'</span>, name);
                        xhrSend(formD);
                    }
                });
            })(i);
    }

```

## 方法2

为什么还有方法2呢，正常情况下方法1没问题，但是需要将分片信息保存在客户端，保存在客户端是最不保险的，说不定出现各种神奇的幺蛾子。

所以这里有一个更完善的实现，只提供思路，代码就不写了，也是基于上面的实现，只是服务端需要增加一个接口。

基于上面一个栗子进行改进，服务端已保存了部分片段，客户端上传前需要从服务端获取已上传的分片信息（上面是保存在了本地浏览器），本地对比每个分片的 hash 值，跳过已上传的部分，只传未上传的分片。

方法1是从本地获取分片信息,这里只需要将此方法的能力改为从服务端获取分片信息就行了。

```
-getUploadedFromStorage
+getUploadedFromServer(fileHash)
```

另外服务端增加一个获取分片的接口供客户端调用，思路最重要，代码就不贴了。

不只会从客户端上传文件到服务器，服务器也会上传文件到其他服务器。

* 读取文件buffer `fs`
* 构建 form-data `form-data`
* 上传文件 `node-fetch`

`NODE`

```
 /**
     * filepath = &#x76F8;&#x5BF9;&#x6839;&#x76EE;&#x5F55;&#x7684;&#x8DEF;&#x5F84;&#x5373;&#x53EF;
     */
   async <span class="hljs-keyword">function</span> getFileBufer(filePath) => {

        <span class="hljs-built_in">return</span> new Promise((resolve) => {
            fs.readFile(filePath, <span class="hljs-keyword">function</span> (err, data) {
                var bufer = null;
                <span class="hljs-keyword">if</span> (!err) {
                    resolve({
                        err: err,
                        data: data
                    });
                }

            });

        });
    }

    /**
     * &#x4E0A;&#x4F20;&#x6587;&#x4EF6;
     */
    <span class="hljs-built_in">let</span> fetch = require(<span class="hljs-string">'node-fetch'</span>);
    <span class="hljs-built_in">let</span> formData = require(<span class="hljs-string">'form-data'</span>);

    module.exports = async (options) => {
        <span class="hljs-built_in">let</span> {
            imgPath
        } = options;
        <span class="hljs-built_in">let</span> data = await getFileBufer(imgPath);
        <span class="hljs-keyword">if</span> (data.err) {
            <span class="hljs-built_in">return</span> null;
        }
        <span class="hljs-built_in">let</span> form = new formData();
        form.append(<span class="hljs-string">'xxx'</span>, xxx);
        form.append(<span class="hljs-string">'pic'</span>, data.data);
        <span class="hljs-built_in">return</span> fetch(<span class="hljs-string">'http://xx.com/upload'</span>, {
            body: form,
            method: <span class="hljs-string">'POST'</span>,
            headers: form.getHeaders()//&#x8981;&#x6D3B;&#x7684; form-data&#x7684;&#x5934;&#xFF0C;&#x5426;&#x5219;&#x65E0;&#x6CD5;&#x4E0A;&#x4F20;
        }).then(res => {
            <span class="hljs-built_in">return</span> res.json();
        }).then(data => {
            <span class="hljs-built_in">return</span> data;
        })
    }
```

## 在浏览器端对文件的类型、大小、尺寸进行判断

* `file.type`判断类型
* `file.size`判断大小
* 通过动态创建 img 标签，图片加载后获得尺寸, `naturalWidth naturalHeight`or `width height`

```
    var file = document.getElementById(<span class="hljs-string">'f1'</span>).files[0];

    //&#x5224;&#x65AD;&#x7C7B;&#x578B;
    <span class="hljs-keyword">if</span>(f.type!==<span class="hljs-string">'image/jpeg'</span> &&  f.type !== <span class="hljs-string">'image/jpg'</span>  ){
        alert(<span class="hljs-string">'&#x53EA;&#x80FD;&#x4E0A;&#x4F20; jpg &#x56FE;&#x7247;'</span>);
        flag=<span class="hljs-literal">false</span>;
        <span class="hljs-built_in">break</span>;
    }

    //&#x5224;&#x65AD;&#x5927;&#x5C0F;
    <span class="hljs-keyword">if</span>(file.size>100*1024){
        alert(<span class="hljs-string">'&#x4E0D;&#x80FD;&#x5927;&#x4E8E;100kb'</span>);
    }

    //&#x5224;&#x65AD;&#x56FE;&#x7247;&#x5C3A;&#x5BF8;
    var img =new Image();
    img.onload=<span class="hljs-function"><span class="hljs-title">function</span></span>(){
         console.log(<span class="hljs-string">'&#x56FE;&#x7247;&#x539F;&#x59CB;&#x5927;&#x5C0F; width*height'</span>, this.width, this.height);
        <span class="hljs-keyword">if</span>(this.naturalWidth){
        console.log(<span class="hljs-string">'&#x56FE;&#x7247;&#x539F;&#x59CB;&#x5927;&#x5C0F; naturalWidth*naturalHeight'</span>, this.naturalWidth, this.naturalHeight);
        }<span class="hljs-keyword">else</span>{
          console.log(<span class="hljs-string">'oImg.width*height'</span>, this.width, this.height);
        }
    }
```

## input file 外观更改

由于input file 的外观比较传统，很多地方都需要进行美化。

```
  <label <span class="hljs-keyword">for=<span class="hljs-string">"file"</span>>Choose file to upload</label>
    <input <span class="hljs-built_in">type=<span class="hljs-string">"file"</span> id=<span class="hljs-string">"file"</span> name=<span class="hljs-string">"file"</span> multiple>
```

file 标签隐藏后在 ie 下无法获得文件内容，建议还是 `&#x65B9;&#x6CD5;1` 兼容性强。

以上代码均已上传 github

* 我正在打造一个纯技术交流群，以学习、交流、思考、提升能力为目标，因为一个人学不如大家一起学，有了更多的交流才会进步的更快。
* 我理想的模式是，每期让一个人深入学习一个技术，然后自己再转述给大家听，类似一个分享课堂，这样可以成倍的提升学习效率
* 在这个群里不用担心自己的能力不足，不用担心问题是否太小白而不敢说，大胆的说出问题， 让更多的人一起来分析，说错了也没关系
* 有想入群的加我微信 `223344386` 回复加群即可

希望本文可以给你带了一些帮助，文中如有错误，欢迎在评论区指。 如果这篇文章帮助到了你，欢迎点赞和关注。

另外推荐关注我的微信公众号【前端技术江湖】，除了深度好文，还有我有精心整理的【500道前端面试题】等你来查收。

**你对 SSR 有兴趣吗？**

如果你对 `&#x670D;&#x52A1;&#x7AEF;&#x6E32;&#x67D3; ssr` 技术有兴趣，可以关注我的开源项目： `Zz.js`

SSR 技术原理
